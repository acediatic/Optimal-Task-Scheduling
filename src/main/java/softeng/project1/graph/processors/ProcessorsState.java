package softeng.project1.graph.processors;

import softeng.project1.graph.processors.processor.Processor;
import softeng.project1.graph.tasks.TaskNode;

import java.util.Arrays;

/**
 * @author Remus Courtenay
 * @version 1.0
 * @since 1.8
 *
 * Abstract implementation of Processors representing the values of a set of processors within a specific partial
 * schedule.
 * Contains the functionality standard amongst all ProcessorsStates: Creating new states with copyAndAdd and returning
 * state field values.
 */
public abstract class ProcessorsState implements Processors {

    // Immutable data fields
    protected final Processor[] processors; // Set of immutable Processor objects, never expose this directly
    protected final int idleTime;   // The sum total amount of time spent idling on each processor before the latest
                                    // scheduled task (on any processor) is finished.

    protected ProcessorsState(Processor[] processors, int idleTime) {
        this.processors = processors;
        this.idleTime = idleTime;
    }

    /**
     * @param processorID : The unique integer ID of the processor.
     * @return : The stored state of the processor with the given ID.
     */
    @Override
    public Processor getProcessor(int processorID) {
        return this.processors[processorID];
    }

    /**
     * @return : The number of processors available for tasks to be scheduled on.
     */
    @Override
    public int getNumProcessors() {
        return this.processors.length;
    }

    /**
     * @return : The sum total amount of time spent idling on each processor before the latest scheduled task (on any
     * processor) is finished.
     */
    @Override
    public int getIdleTime() {
        return this.idleTime;
    }

    /**
     * Generates a new Processors object which is a copy of the current except for one processor. The changed processor
     * is generated by getting it's state after the given task is inserted into its currently held state.
     * As Processor objects are immutable we copy the references of the unchanged Processor objects rather than make and
     * store copies of them.
     *
     * @param newNode : The new task to be greedily inserted into a processor creating a new processor state.
     * @param processorID : The ID of the processor that the task is to be inserted into.
     * @return : New Processors object representing the state of the Processors after the given task is inserted into
     *           the specified Processor.
     */
    @Override
    public Processors copyAndAddProcessor(TaskNode newNode, int processorID) {
        // TODO... See if this can be done faster without copying the replaceable Processor.
        Processor[] newProcessors = Arrays.copyOf(this.processors, this.processors.length);
        Processor newProcessor = this.processors[processorID].copyAndInsert(newNode);
        newProcessors[processorID] = newProcessor;

        return new ChangedProcessorsState(
                newProcessors,
                calculateMaxProcessorLength(newProcessor),
                calculateIdleTime(newProcessor)
        );
    }

    /**
     * Implementation specific helper method that calculates the length of the longest stored Processor for the new
     * ProcessorsState object.
     * @param newProcessor : The changed Processor.
     * @return : The length of the longest Processor schedule.
     */
    protected abstract int calculateMaxProcessorLength(Processor newProcessor);

    /**
     * Implementation specific helper method that calculates the total idle time amongst all Processor objects for the
     * new ProcessorsState object.
     * @param newProcessor : The changed Processor.
     * @return : The sum total idle time of the new ProcessorsState object.
     */
    protected abstract int calculateIdleTime(Processor newProcessor);
}
